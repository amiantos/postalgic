//
//  GitPublisher.swift
//  Postalgic
//
//  Created by Claude on 5/14/25.
//

import Foundation
import AsyncSwiftGit

/// GitPublisher handles the publishing of a static site to a Git repository
class GitPublisher: Publisher {
    private let repositoryUrl: String
    private let username: String
    private let password: String
    private let branch: String
    private let commitMessage: String
    
    var publisherType: PublisherType { .git }
    
    init(
        repositoryUrl: String,
        username: String,
        password: String,
        branch: String,
        commitMessage: String
    ) {
        self.repositoryUrl = repositoryUrl
        self.username = username
        self.password = password
        self.branch = branch
        self.commitMessage = commitMessage
    }
    
    /// Publishes the static site from the given directory to a Git repository
    func publish(directoryURL: URL, statusUpdate: @escaping (String) -> Void = { _ in }) async throws -> URL? {
        statusUpdate("Starting Git repository operations...")
        
        // Create a temporary directory for the Git repository
        let fileManager = FileManager.default
        let tempRepoURL = fileManager.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        
        do {
            // Step 1: Try to clone the repository if it exists, otherwise initialize a new one
            statusUpdate("Setting up Git repository...")
            
            if fileManager.fileExists(atPath: tempRepoURL.path) {
                try fileManager.removeItem(at: tempRepoURL)
            }
            
            // Try to clone the existing repository first
            var repo: Repository
            do {
                // Attempt to clone the repository
                statusUpdate("Cloning remote repository...")
                
                let credentials = Credentials.plaintext(username: username, password: password)
                let repoUrlObj = URL(string: repositoryUrl)!
                repo = try await Repository.clone(
                    from: repoUrlObj,
                    to: tempRepoURL,
                    credentials: credentials
                )
                
                // Checkout the target branch if it exists, or create it
                statusUpdate("Checking out branch: \(branch)...")
                
                // Try to checkout the branch
                var checkoutStream = repo.checkoutProgress(referenceShorthand: branch)
                for try await _ in checkoutStream {
                    // Process checkout progress if needed
                }
            } catch {
                // If cloning fails, initialize a new repository
                statusUpdate("Remote repository not accessible or empty, initializing new repository...")
                try fileManager.createDirectory(at: tempRepoURL, withIntermediateDirectories: true)
                
                repo = try Repository(createAt: tempRepoURL, bare: false)
                
                // Create initial commit on main branch before creating our target branch
                statusUpdate("Creating initial commit...")
                // Create a signature for the commit
                let signature = try Signature(name: username, email: "\(username)@postalgic.app")
                
                // Add a README initially to have something to commit
                let readmePath = tempRepoURL.appendingPathComponent("README.md")
                try "# Generated by Postalgic\n".write(to: readmePath, atomically: true, encoding: .utf8)
                
                try repo.add("README.md")
                try repo.commit(message: "Initial commit", signature: signature)
                
                // Now create our target branch if it's not main/master
                if branch != "main" && branch != "master" {
                    statusUpdate("Creating branch: \(branch)...")
                    // Need the OID of the current HEAD commit
                    if let headOID = try repo.headObjectID {
                        try repo.createBranch(named: branch, commitOID: headOID)
                        
                        // Checkout the branch
                        var checkoutStream = repo.checkoutProgress(referenceShorthand: branch)
                        for try await _ in checkoutStream {
                            // Process checkout progress if needed
                        }
                    } else {
                        statusUpdate("Warning: Could not get HEAD commit for branch creation")
                    }
                }
                
                // Set up the remote
                statusUpdate("Adding remote: origin")
                let repoUrlObj = URL(string: repositoryUrl)!
                try repo.addRemote("origin", url: repoUrlObj)
            }
            
            // Step 2: Copy the site files to the repository
            statusUpdate("Copying site files to repository...")
            
            // Get list of files from the generated site
            let siteContents = try fileManager.contentsOfDirectory(
                at: directoryURL,
                includingPropertiesForKeys: nil,
                options: [.skipsHiddenFiles]
            )
            
            // Copy all files from the generated site to the repository
            for item in siteContents {
                let destination = tempRepoURL.appendingPathComponent(item.lastPathComponent)

                if fileManager.fileExists(atPath: destination.path) {
                    // Remove existing item first (works for both files and directories)
                    try fileManager.removeItem(at: destination)
                }
                // Copy new item
                try fileManager.copyItem(at: item, to: destination)
            }
            
            // Step 3: Stage all changes
            statusUpdate("Staging changes...")
            
            // Add all files to the index
            try repo.add("*")
            
            // Step 4: Create commit
            statusUpdate("Creating commit...")
            
            // Create a signature for the commit
            let signature = try Signature(name: username, email: "\(username)@postalgic.app")
            
            // Create commit with the specified message
            let message = commitMessage.isEmpty ? "Update site content" : commitMessage
            try repo.commit(message: message, signature: signature)
            
            // Step 5: Push to remote
            statusUpdate("Pushing to remote repository...")
            
            // Create refspecs for pushing
            let refspecs = ["refs/heads/\(branch):refs/heads/\(branch)"]
            
            // Push the changes to the remote repository
            try await repo.push(
                remoteName: "origin",
                refspecs: refspecs,
                credentials: .plaintext(username: username, password: password)
            )
            
            statusUpdate("Successfully published to Git repository")
            
            // Clean up - remove the temporary repository
            try fileManager.removeItem(at: tempRepoURL)
            
            return nil // Git publisher doesn't return a local URL
        } catch {
            // Clean up on error
            if fileManager.fileExists(atPath: tempRepoURL.path) {
                try? fileManager.removeItem(at: tempRepoURL)
            }
            
            statusUpdate("Error publishing to Git repository: \(error.localizedDescription)")
            throw GitPublisherError.publishFailed(error.localizedDescription)
        }
    }
    
    /// Smart publish implementation that optimizes which files to update
    func smartPublish(directoryURL: URL, modifiedFiles: [String], deletedFiles: [String], statusUpdate: @escaping (String) -> Void) async throws -> URL? {
        // For simplicity, we'll use the full publish method for now
        // In a more advanced implementation, we could selectively update only the changed files
        statusUpdate("Performing Git smart publish (full site republish)...")
        return try await publish(directoryURL: directoryURL, statusUpdate: statusUpdate)
    }
    
    // MARK: - Remote Hash File Support

    /// Path for the remote hash file
    private static let hashFilePath = ".postalgic/hashes.json"

    /// Fetches the remote hash file from the Git repository
    func fetchRemoteHashes() async -> RemoteHashFile? {
        let fileManager = FileManager.default
        let tempRepoURL = fileManager.temporaryDirectory.appendingPathComponent("postalgic-hash-check-\(UUID().uuidString)")

        do {
            // Clone the repository to read the hash file
            let credentials = Credentials.plaintext(username: username, password: password)
            let repoUrlObj = URL(string: repositoryUrl)!
            _ = try await Repository.clone(
                from: repoUrlObj,
                to: tempRepoURL,
                credentials: credentials
            )

            // Read the hash file if it exists
            let hashFilePath = tempRepoURL.appendingPathComponent(Self.hashFilePath)

            guard fileManager.fileExists(atPath: hashFilePath.path) else {
                print("ðŸ“¦ No remote hash file found in repository")
                try? fileManager.removeItem(at: tempRepoURL)
                return nil
            }

            let data = try Data(contentsOf: hashFilePath)
            let hashFile = try JSONDecoder().decode(RemoteHashFile.self, from: data)
            print("ðŸ“¦ Found remote hash file from \(hashFile.appSource) with \(hashFile.fileHashes.count) files")

            // Clean up temp directory
            try? fileManager.removeItem(at: tempRepoURL)

            return hashFile

        } catch {
            print("ðŸ“¦ Failed to fetch remote hashes from Git: \(error.localizedDescription)")
            try? fileManager.removeItem(at: tempRepoURL)
            return nil
        }
    }

    /// Writes the hash file to a local directory (for Git, this is called before publish)
    /// The hash file gets committed with the rest of the site
    func uploadHashFile(hashes: [String: String]) async throws {
        // For Git publisher, the hash file is written to the site directory
        // by StaticSiteGenerator before publish() is called, so this is a no-op.
        // The hash file gets committed along with the rest of the site.
        print("ðŸ“¦ Git publisher: hash file should be written to site directory before publish")
    }

    /// Writes the hash file to a specific directory (used by StaticSiteGenerator for Git publishing)
    func writeHashFile(to directoryURL: URL, hashes: [String: String]) throws {
        let hashFile = RemoteHashFile(appSource: "ios", fileHashes: hashes)
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        let data = try encoder.encode(hashFile)

        // Create .postalgic directory if needed
        let postalgicDir = directoryURL.appendingPathComponent(".postalgic")
        try FileManager.default.createDirectory(at: postalgicDir, withIntermediateDirectories: true)

        // Write the hash file
        let hashFilePath = directoryURL.appendingPathComponent(Self.hashFilePath)
        try data.write(to: hashFilePath)
        print("ðŸ“¦ Wrote hash file to \(hashFilePath.path) with \(hashes.count) file hashes")
    }

    /// Error types that can occur during Git operations
    enum GitPublisherError: Error, LocalizedError {
        case publishFailed(String)
        case cloneFailed(String)
        case pushFailed(String)

        var localizedDescription: String {
            switch self {
            case .publishFailed(let message):
                return "Git publish failed: \(message)"
            case .cloneFailed(let message):
                return "Git clone failed: \(message)"
            case .pushFailed(let message):
                return "Git push failed: \(message)"
            }
        }
    }
}
