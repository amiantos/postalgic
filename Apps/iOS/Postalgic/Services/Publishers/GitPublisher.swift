//
//  GitPublisher.swift
//  Postalgic
//
//  Created by Claude on 5/14/25.
//

import Foundation
import AsyncSwiftGit

/// GitPublisher handles the publishing of a static site to a Git repository
class GitPublisher: Publisher {
    private let repositoryUrl: String
    private let username: String
    private let password: String
    private let branch: String
    private let commitMessage: String
    
    var publisherType: PublisherType { .git }
    
    init(
        repositoryUrl: String,
        username: String,
        password: String,
        branch: String,
        commitMessage: String
    ) {
        self.repositoryUrl = repositoryUrl
        self.username = username
        self.password = password
        self.branch = branch
        self.commitMessage = commitMessage
    }
    
    /// Publishes the static site from the given directory to a Git repository
    func publish(directoryURL: URL, statusUpdate: @escaping (String) -> Void = { _ in }) async throws -> URL? {
        statusUpdate("Starting Git repository operations...")
        
        // Create a temporary directory for the Git repository
        let fileManager = FileManager.default
        let tempRepoURL = fileManager.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        
        do {
            // Step 1: Try to clone the repository if it exists, otherwise initialize a new one
            statusUpdate("Setting up Git repository...")
            
            if fileManager.fileExists(atPath: tempRepoURL.path) {
                try fileManager.removeItem(at: tempRepoURL)
            }
            
            // Try to clone the existing repository first
            var repo: Repository
            do {
                // Attempt to clone the repository
                statusUpdate("Cloning remote repository...")
                
                let credentials = Credentials.plaintext(username: username, password: password)
                let repoUrlObj = URL(string: repositoryUrl)!
                repo = try await Repository.clone(
                    from: repoUrlObj,
                    to: tempRepoURL,
                    credentials: credentials
                )
                
                // Checkout the target branch if it exists, or create it
                statusUpdate("Checking out branch: \(branch)...")
                
                // Try to checkout the branch
                var checkoutStream = repo.checkoutProgress(referenceShorthand: branch)
                for try await _ in checkoutStream {
                    // Process checkout progress if needed
                }
            } catch {
                // If cloning fails, initialize a new repository
                statusUpdate("Remote repository not accessible or empty, initializing new repository...")
                try fileManager.createDirectory(at: tempRepoURL, withIntermediateDirectories: true)
                
                repo = try Repository(createAt: tempRepoURL, bare: false)
                
                // Create initial commit on main branch before creating our target branch
                statusUpdate("Creating initial commit...")
                // Create a signature for the commit
                let signature = try Signature(name: username, email: "\(username)@postalgic.app")
                
                // Add a README initially to have something to commit
                let readmePath = tempRepoURL.appendingPathComponent("README.md")
                try "# Generated by Postalgic\n".write(to: readmePath, atomically: true, encoding: .utf8)
                
                try repo.add("README.md")
                try repo.commit(message: "Initial commit", signature: signature)
                
                // Now create our target branch if it's not main/master
                if branch != "main" && branch != "master" {
                    statusUpdate("Creating branch: \(branch)...")
                    // Need the OID of the current HEAD commit
                    if let headOID = try repo.headObjectID {
                        try repo.createBranch(named: branch, commitOID: headOID)
                        
                        // Checkout the branch
                        var checkoutStream = repo.checkoutProgress(referenceShorthand: branch)
                        for try await _ in checkoutStream {
                            // Process checkout progress if needed
                        }
                    } else {
                        statusUpdate("Warning: Could not get HEAD commit for branch creation")
                    }
                }
                
                // Set up the remote
                statusUpdate("Adding remote: origin")
                let repoUrlObj = URL(string: repositoryUrl)!
                try repo.addRemote("origin", url: repoUrlObj)
            }
            
            // Step 2: Copy the site files to the repository
            statusUpdate("Copying site files to repository...")
            
            // Get list of files from the generated site
            let siteContents = try fileManager.contentsOfDirectory(
                at: directoryURL,
                includingPropertiesForKeys: nil,
                options: [.skipsHiddenFiles]
            )
            
            // Copy all files from the generated site to the repository
            for item in siteContents {
                let destination = tempRepoURL.appendingPathComponent(item.lastPathComponent)
                
                if fileManager.fileExists(atPath: destination.path) {
                    // Replace existing file
                    _ = try fileManager.replaceItem(at: destination, withItemAt: item, backupItemName: nil, options: [], resultingItemURL: nil)
                } else {
                    // Copy new file
                    try fileManager.copyItem(at: item, to: destination)
                }
            }
            
            // Step 3: Stage all changes
            statusUpdate("Staging changes...")
            
            // Add all files to the index
            try repo.add("*")
            
            // Step 4: Create commit
            statusUpdate("Creating commit...")
            
            // Create a signature for the commit
            let signature = try Signature(name: username, email: "\(username)@postalgic.app")
            
            // Create commit with the specified message
            let message = commitMessage.isEmpty ? "Update site content" : commitMessage
            try repo.commit(message: message, signature: signature)
            
            // Step 5: Push to remote
            statusUpdate("Pushing to remote repository...")
            
            // Create refspecs for pushing
            let refspecs = ["refs/heads/\(branch):refs/heads/\(branch)"]
            
            // Push the changes to the remote repository
            try await repo.push(
                remoteName: "origin",
                refspecs: refspecs,
                credentials: .plaintext(username: username, password: password)
            )
            
            statusUpdate("Successfully published to Git repository")
            
            // Clean up - remove the temporary repository
            try fileManager.removeItem(at: tempRepoURL)
            
            return nil // Git publisher doesn't return a local URL
        } catch {
            // Clean up on error
            if fileManager.fileExists(atPath: tempRepoURL.path) {
                try? fileManager.removeItem(at: tempRepoURL)
            }
            
            statusUpdate("Error publishing to Git repository: \(error.localizedDescription)")
            throw GitPublisherError.publishFailed(error.localizedDescription)
        }
    }
    
    /// Smart publish implementation that optimizes which files to update
    func smartPublish(directoryURL: URL, modifiedFiles: [String], deletedFiles: [String], statusUpdate: @escaping (String) -> Void) async throws -> URL? {
        // For simplicity, we'll use the full publish method for now
        // In a more advanced implementation, we could selectively update only the changed files
        statusUpdate("Performing Git smart publish (full site republish)...")
        return try await publish(directoryURL: directoryURL, statusUpdate: statusUpdate)
    }
    
    /// Error types that can occur during Git operations
    enum GitPublisherError: Error, LocalizedError {
        case publishFailed(String)
        case cloneFailed(String)
        case pushFailed(String)
        
        var localizedDescription: String {
            switch self {
            case .publishFailed(let message):
                return "Git publish failed: \(message)"
            case .cloneFailed(let message):
                return "Git clone failed: \(message)"
            case .pushFailed(let message):
                return "Git push failed: \(message)"
            }
        }
    }
}
