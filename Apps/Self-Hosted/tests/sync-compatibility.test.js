/**
 * Sync Compatibility Tests
 *
 * These tests verify that the sync data generated by the Self-Hosted app
 * matches the expected structure and is compatible with the iOS app.
 */

import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import os from 'os';
import { v4 as uuidv4 } from 'uuid';

// Import the modules we're testing
import { generateSyncDirectory } from '../server/services/syncGenerator.js';
import { generateSite } from '../server/services/siteGenerator.js';
import Storage from '../server/utils/storage.js';
import { initDatabase, closeDatabase } from '../server/utils/database.js';
import { calculateHash } from '../server/utils/helpers.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Load test fixtures
const fixturesDir = path.join(__dirname, '../../..', 'test-fixtures/sync-compatibility');
const canonicalBlog = JSON.parse(fs.readFileSync(path.join(fixturesDir, 'canonical-blog.json'), 'utf8'));
const expectedStructure = JSON.parse(fs.readFileSync(path.join(fixturesDir, 'expected-sync-structure.json'), 'utf8'));

describe('Sync Data Compatibility', () => {
  let storage;
  let testDir;
  let blogId;
  let testIdToRealId = {};

  beforeAll(() => {
    // Create a temporary directory for test data
    testDir = path.join(os.tmpdir(), `postalgic-test-${uuidv4()}`);
    fs.mkdirSync(testDir, { recursive: true });

    // Initialize database first
    initDatabase(testDir);

    // Initialize storage with test directory
    storage = new Storage(testDir);

    // Create blog from fixture
    const blog = storage.createBlog({
      name: canonicalBlog.blog.name,
      url: canonicalBlog.blog.url,
      tagline: canonicalBlog.blog.tagline,
      authorName: canonicalBlog.blog.authorName,
      authorUrl: canonicalBlog.blog.authorUrl,
      authorEmail: canonicalBlog.blog.authorEmail,
      accentColor: canonicalBlog.blog.colors.accent,
      backgroundColor: canonicalBlog.blog.colors.background,
      textColor: canonicalBlog.blog.colors.text,
      lightShade: canonicalBlog.blog.colors.lightShade,
      mediumShade: canonicalBlog.blog.colors.mediumShade,
      darkShade: canonicalBlog.blog.colors.darkShade,
      themeIdentifier: canonicalBlog.blog.themeIdentifier,
    });
    blogId = blog.id;

    // Enable sync for the blog
    storage.saveSyncConfig(blogId, {
      syncEnabled: true,
      syncPassword: canonicalBlog.encryption.testPassword,
      lastSyncedAt: null,
      lastSyncedVersion: 0,
    });

    // Create categories
    for (const cat of canonicalBlog.categories) {
      const created = storage.createCategory(blogId, {
        name: cat.name,
        description: cat.description,
        stub: cat.stub,
      });
      testIdToRealId[cat.testId] = created.id;
    }

    // Create tags
    for (const tag of canonicalBlog.tags) {
      const created = storage.createTag(blogId, {
        name: tag.name,
        stub: tag.stub,
      });
      testIdToRealId[tag.testId] = created.id;
    }

    // Create posts (published)
    for (const post of canonicalBlog.posts) {
      const categoryId = post.categoryTestId ? testIdToRealId[post.categoryTestId] : null;
      const tagIds = post.tagTestIds.map(tid => testIdToRealId[tid]);

      let embed = null;
      if (post.embed) {
        embed = {
          type: post.embed.type.toLowerCase(),
          position: post.embed.position.toLowerCase(),
          url: post.embed.url,
          title: post.embed.title,
          description: post.embed.description,
          imageUrl: post.embed.imageUrl,
          imageFilename: post.embed.imageFilename,
          images: post.embed.images,
        };
      }

      const created = storage.createPost(blogId, {
        title: post.title,
        content: post.content,
        stub: post.stub,
        isDraft: post.isDraft,
        categoryId: categoryId,
        tagIds: tagIds,
        embed: embed,
        createdAt: post.createdAt,
      });
      testIdToRealId[post.testId] = created.id;
    }

    // Create drafts
    for (const draft of canonicalBlog.drafts) {
      const categoryId = draft.categoryTestId ? testIdToRealId[draft.categoryTestId] : null;
      const tagIds = draft.tagTestIds.map(tid => testIdToRealId[tid]);

      const created = storage.createPost(blogId, {
        title: draft.title,
        content: draft.content,
        stub: draft.stub,
        isDraft: true,
        categoryId: categoryId,
        tagIds: tagIds,
        embed: null,
        createdAt: draft.createdAt,
      });
      testIdToRealId[draft.testId] = created.id;
    }

    // Create sidebar objects
    for (const sidebar of canonicalBlog.sidebar) {
      const created = storage.createSidebarObject(blogId, {
        type: sidebar.type,
        title: sidebar.title,
        content: sidebar.content,
        order: sidebar.order,
        links: sidebar.links,
      });
      testIdToRealId[sidebar.testId] = created.id;
    }
  });

  afterAll(() => {
    // Close database first
    closeDatabase();

    // Clean up test directory
    if (testDir && fs.existsSync(testDir)) {
      fs.rmSync(testDir, { recursive: true, force: true });
    }
  });

  describe('Sync Directory Generation', () => {
    let syncOutputDir;
    let syncResult;

    beforeAll(async () => {
      // Generate sync directory
      syncOutputDir = path.join(testDir, 'output');
      fs.mkdirSync(syncOutputDir, { recursive: true });

      syncResult = await generateSyncDirectory(
        storage,
        blogId,
        syncOutputDir,
        canonicalBlog.encryption.testPassword
      );
    });

    it('should create manifest.json', () => {
      const manifestPath = path.join(syncOutputDir, 'sync', 'manifest.json');
      expect(fs.existsSync(manifestPath)).toBe(true);
    });

    it('should have all required manifest fields', () => {
      const manifest = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'manifest.json'), 'utf8')
      );

      // Check for current manifest structure
      expect(manifest).toHaveProperty('version');
      expect(manifest).toHaveProperty('contentVersion');
      expect(manifest).toHaveProperty('lastModified');
      expect(manifest).toHaveProperty('appSource');
      expect(manifest).toHaveProperty('blogName');
      expect(manifest).toHaveProperty('files');
      expect(manifest).toHaveProperty('fileCount');
    });

    it('should have correct manifest field types', () => {
      const manifest = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'manifest.json'), 'utf8')
      );

      expect(typeof manifest.version).toBe('string');
      expect(typeof manifest.contentVersion).toBe('string');
      expect(typeof manifest.lastModified).toBe('string');
      expect(typeof manifest.appSource).toBe('string');
      expect(typeof manifest.blogName).toBe('string');
      expect(typeof manifest.files).toBe('object');
      expect(typeof manifest.fileCount).toBe('number');
    });

    it('should create blog.json with correct structure', () => {
      const blogPath = path.join(syncOutputDir, 'sync', 'blog.json');
      expect(fs.existsSync(blogPath)).toBe(true);

      const blogData = JSON.parse(fs.readFileSync(blogPath, 'utf8'));

      for (const field of expectedStructure.blog.requiredFields) {
        expect(blogData).toHaveProperty(field);
      }

      expect(blogData.name).toBe(canonicalBlog.blog.name);
      expect(blogData.url).toBe(canonicalBlog.blog.url);
    });

    it('should create categories index and individual files', () => {
      const indexPath = path.join(syncOutputDir, 'sync', 'categories', 'index.json');
      expect(fs.existsSync(indexPath)).toBe(true);

      const index = JSON.parse(fs.readFileSync(indexPath, 'utf8'));
      expect(index.categories).toHaveLength(canonicalBlog.categories.length);

      // Check each category file exists
      for (const entry of index.categories) {
        const catPath = path.join(syncOutputDir, 'sync', 'categories', `${entry.id}.json`);
        expect(fs.existsSync(catPath)).toBe(true);
      }
    });

    it('should create tags index and individual files', () => {
      const indexPath = path.join(syncOutputDir, 'sync', 'tags', 'index.json');
      expect(fs.existsSync(indexPath)).toBe(true);

      const index = JSON.parse(fs.readFileSync(indexPath, 'utf8'));
      expect(index.tags).toHaveLength(canonicalBlog.tags.length);

      // Check each tag file exists
      for (const entry of index.tags) {
        const tagPath = path.join(syncOutputDir, 'sync', 'tags', `${entry.id}.json`);
        expect(fs.existsSync(tagPath)).toBe(true);
      }
    });

    it('should create posts index and individual files', () => {
      const indexPath = path.join(syncOutputDir, 'sync', 'posts', 'index.json');
      expect(fs.existsSync(indexPath)).toBe(true);

      const index = JSON.parse(fs.readFileSync(indexPath, 'utf8'));
      expect(index.posts).toHaveLength(canonicalBlog.posts.length);

      // Check each post file exists
      for (const entry of index.posts) {
        const postPath = path.join(syncOutputDir, 'sync', 'posts', `${entry.id}.json`);
        expect(fs.existsSync(postPath)).toBe(true);
      }
    });

    it('should create sidebar index and individual files', () => {
      const indexPath = path.join(syncOutputDir, 'sync', 'sidebar', 'index.json');
      expect(fs.existsSync(indexPath)).toBe(true);

      const index = JSON.parse(fs.readFileSync(indexPath, 'utf8'));
      expect(index.sidebar).toHaveLength(canonicalBlog.sidebar.length);

      // Check each sidebar file exists
      for (const entry of index.sidebar) {
        const sidebarPath = path.join(syncOutputDir, 'sync', 'sidebar', `${entry.id}.json`);
        expect(fs.existsSync(sidebarPath)).toBe(true);
      }
    });

    it('should have valid SHA-256 hashes in manifest', () => {
      const manifest = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'manifest.json'), 'utf8')
      );

      const sha256Regex = /^[a-f0-9]{64}$/;

      for (const [filePath, fileInfo] of Object.entries(manifest.files)) {
        expect(fileInfo.hash).toMatch(sha256Regex);
      }
    });

  });

  describe('Post Structure', () => {
    let syncOutputDir;

    beforeAll(async () => {
      syncOutputDir = path.join(testDir, 'output');
    });

    it('should have correct post structure with embed', () => {
      const indexPath = path.join(syncOutputDir, 'sync', 'posts', 'index.json');
      const index = JSON.parse(fs.readFileSync(indexPath, 'utf8'));

      // Find a post with embed
      for (const entry of index.posts) {
        const postPath = path.join(syncOutputDir, 'sync', 'posts', `${entry.id}.json`);
        const post = JSON.parse(fs.readFileSync(postPath, 'utf8'));

        // Check required fields
        expect(post).toHaveProperty('id');
        expect(post).toHaveProperty('content');
        expect(post).toHaveProperty('stub');
        expect(post).toHaveProperty('createdAt');
        expect(post).toHaveProperty('updatedAt');

        // If has embed, check embed structure
        if (post.embed) {
          expect(post.embed).toHaveProperty('type');
          expect(post.embed).toHaveProperty('position');
          expect(['YouTube', 'Link', 'Image']).toContain(post.embed.type);
          expect(['above', 'below']).toContain(post.embed.position);
        }
      }
    });

    it('should have valid category references', () => {
      const postIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'posts', 'index.json'), 'utf8')
      );
      const catIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'categories', 'index.json'), 'utf8')
      );

      const validCategoryIds = new Set(catIndex.categories.map(c => c.id));

      for (const entry of postIndex.posts) {
        const postPath = path.join(syncOutputDir, 'sync', 'posts', `${entry.id}.json`);
        const post = JSON.parse(fs.readFileSync(postPath, 'utf8'));

        if (post.categoryId) {
          expect(validCategoryIds.has(post.categoryId)).toBe(true);
        }
      }
    });

    it('should have valid tag references', () => {
      const postIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'posts', 'index.json'), 'utf8')
      );
      const tagIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'tags', 'index.json'), 'utf8')
      );

      const validTagIds = new Set(tagIndex.tags.map(t => t.id));

      for (const entry of postIndex.posts) {
        const postPath = path.join(syncOutputDir, 'sync', 'posts', `${entry.id}.json`);
        const post = JSON.parse(fs.readFileSync(postPath, 'utf8'));

        if (post.tagIds && post.tagIds.length > 0) {
          for (const tagId of post.tagIds) {
            expect(validTagIds.has(tagId)).toBe(true);
          }
        }
      }
    });
  });

  describe('Date Format', () => {
    let syncOutputDir;

    beforeAll(async () => {
      syncOutputDir = path.join(testDir, 'output');
    });

    it('should use ISO 8601 date format', () => {
      const iso8601Regex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/;

      // Check manifest
      const manifest = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'manifest.json'), 'utf8')
      );
      expect(manifest.lastModified).toMatch(iso8601Regex);

      // Check posts
      const postIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'posts', 'index.json'), 'utf8')
      );

      for (const entry of postIndex.posts) {
        const postPath = path.join(syncOutputDir, 'sync', 'posts', `${entry.id}.json`);
        const post = JSON.parse(fs.readFileSync(postPath, 'utf8'));
        expect(post.createdAt).toMatch(iso8601Regex);
        expect(post.updatedAt).toMatch(iso8601Regex);
      }
    });
  });

  describe('Import/Export Parity', () => {
    let syncOutputDir;
    let importedBlogId;
    let importedIdMap = {};

    beforeAll(async () => {
      syncOutputDir = path.join(testDir, 'output');

      // Create a new blog to import into
      const importedBlog = storage.createBlog({
        name: 'Imported Blog',
        url: canonicalBlog.blog.url,
      });
      importedBlogId = importedBlog.id;

      // Read and import categories from sync data
      const catIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'categories', 'index.json'), 'utf8')
      );
      for (const entry of catIndex.categories) {
        const catData = JSON.parse(
          fs.readFileSync(path.join(syncOutputDir, 'sync', 'categories', `${entry.id}.json`), 'utf8')
        );
        const created = storage.createCategory(importedBlogId, {
          name: catData.name,
          description: catData.description,
          stub: catData.stub,
          syncId: catData.id,
          createdAt: catData.createdAt, // This is what we're testing!
        });
        importedIdMap[catData.id] = created.id;
      }

      // Read and import tags from sync data
      const tagIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'tags', 'index.json'), 'utf8')
      );
      for (const entry of tagIndex.tags) {
        const tagData = JSON.parse(
          fs.readFileSync(path.join(syncOutputDir, 'sync', 'tags', `${entry.id}.json`), 'utf8')
        );
        const created = storage.createTag(importedBlogId, {
          name: tagData.name,
          stub: tagData.stub,
          syncId: tagData.id,
          createdAt: tagData.createdAt, // This is what we're testing!
        });
        importedIdMap[tagData.id] = created.id;
      }

      // Read and import sidebar from sync data
      const sidebarIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'sidebar', 'index.json'), 'utf8')
      );
      for (const entry of sidebarIndex.sidebar) {
        const sidebarData = JSON.parse(
          fs.readFileSync(path.join(syncOutputDir, 'sync', 'sidebar', `${entry.id}.json`), 'utf8')
        );
        storage.createSidebarObject(importedBlogId, {
          title: sidebarData.title,
          type: sidebarData.type,
          content: sidebarData.content,
          order: sidebarData.order,
          links: sidebarData.links || [],
          syncId: sidebarData.id,
          createdAt: sidebarData.createdAt, // This is what we're testing!
        });
      }

      // Read and import posts from sync data
      const postIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'posts', 'index.json'), 'utf8')
      );
      for (const entry of postIndex.posts) {
        const postData = JSON.parse(
          fs.readFileSync(path.join(syncOutputDir, 'sync', 'posts', `${entry.id}.json`), 'utf8')
        );

        const categoryId = postData.categoryId ? importedIdMap[postData.categoryId] : null;
        const tagIds = (postData.tagIds || []).map(id => importedIdMap[id]).filter(Boolean);

        let embed = null;
        if (postData.embed) {
          embed = {
            type: postData.embed.type.toLowerCase(),
            position: postData.embed.position.toLowerCase(),
            url: postData.embed.url,
            title: postData.embed.title,
            description: postData.embed.description,
            imageUrl: postData.embed.imageUrl,
            imageFilename: postData.embed.imageFilename,
            images: postData.embed.images,
          };
        }

        storage.createPost(importedBlogId, {
          title: postData.title,
          content: postData.content,
          stub: postData.stub,
          isDraft: false,
          categoryId: categoryId,
          tagIds: tagIds,
          embed: embed,
          syncId: postData.id,
          createdAt: postData.createdAt,
          updatedAt: postData.updatedAt,
        });
      }
    });

    it('should preserve createdAt for categories during import', () => {
      // Read original category
      const catIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'categories', 'index.json'), 'utf8')
      );
      const originalCat = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'categories', `${catIndex.categories[0].id}.json`), 'utf8')
      );

      // Get imported category
      const importedCat = storage.getCategoryBySyncId(importedBlogId, originalCat.id);

      expect(importedCat).toBeDefined();
      expect(importedCat.createdAt).toBe(originalCat.createdAt);
    });

    it('should preserve createdAt for tags during import', () => {
      // Read original tag
      const tagIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'tags', 'index.json'), 'utf8')
      );
      const originalTag = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'tags', `${tagIndex.tags[0].id}.json`), 'utf8')
      );

      // Get imported tag
      const importedTag = storage.getTagBySyncId(importedBlogId, originalTag.id);

      expect(importedTag).toBeDefined();
      expect(importedTag.createdAt).toBe(originalTag.createdAt);
    });

    it('should preserve createdAt for sidebar objects during import', () => {
      // Read original sidebar
      const sidebarIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'sidebar', 'index.json'), 'utf8')
      );
      const originalSidebar = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'sidebar', `${sidebarIndex.sidebar[0].id}.json`), 'utf8')
      );

      // Get imported sidebar
      const importedSidebar = storage.getSidebarObjectBySyncId(importedBlogId, originalSidebar.id);

      expect(importedSidebar).toBeDefined();
      expect(importedSidebar.createdAt).toBe(originalSidebar.createdAt);
    });

    it('should generate identical category JSON after import (hash parity)', async () => {
      // Generate sync data for imported blog
      const importedOutputDir = path.join(testDir, 'imported-output');
      fs.mkdirSync(importedOutputDir, { recursive: true });

      await generateSyncDirectory(storage, importedBlogId, importedOutputDir, null);

      // Compare category hashes
      const originalCatIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'categories', 'index.json'), 'utf8')
      );

      for (const entry of originalCatIndex.categories) {
        const originalContent = fs.readFileSync(
          path.join(syncOutputDir, 'sync', 'categories', `${entry.id}.json`), 'utf8'
        );
        const importedContent = fs.readFileSync(
          path.join(importedOutputDir, 'sync', 'categories', `${entry.id}.json`), 'utf8'
        );

        const originalHash = calculateHash(originalContent);
        const importedHash = calculateHash(importedContent);

        expect(importedHash).toBe(originalHash);
      }
    });

    it('should generate identical tag JSON after import (hash parity)', async () => {
      // Generate sync data for imported blog (use existing from previous test)
      const importedOutputDir = path.join(testDir, 'imported-output');

      // Compare tag hashes
      const originalTagIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'tags', 'index.json'), 'utf8')
      );

      for (const entry of originalTagIndex.tags) {
        const originalContent = fs.readFileSync(
          path.join(syncOutputDir, 'sync', 'tags', `${entry.id}.json`), 'utf8'
        );
        const importedContent = fs.readFileSync(
          path.join(importedOutputDir, 'sync', 'tags', `${entry.id}.json`), 'utf8'
        );

        const originalHash = calculateHash(originalContent);
        const importedHash = calculateHash(importedContent);

        expect(importedHash).toBe(originalHash);
      }
    });

    it('should generate identical sidebar JSON after import (hash parity)', async () => {
      const importedOutputDir = path.join(testDir, 'imported-output');

      // Compare sidebar hashes
      const originalSidebarIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'sidebar', 'index.json'), 'utf8')
      );

      for (const entry of originalSidebarIndex.sidebar) {
        const originalContent = fs.readFileSync(
          path.join(syncOutputDir, 'sync', 'sidebar', `${entry.id}.json`), 'utf8'
        );
        const importedContent = fs.readFileSync(
          path.join(importedOutputDir, 'sync', 'sidebar', `${entry.id}.json`), 'utf8'
        );

        const originalHash = calculateHash(originalContent);
        const importedHash = calculateHash(importedContent);

        expect(importedHash).toBe(originalHash);
      }
    });

    it('should generate identical post JSON after import (hash parity)', async () => {
      const importedOutputDir = path.join(testDir, 'imported-output');

      // Compare post hashes
      const originalPostIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'posts', 'index.json'), 'utf8')
      );

      for (const entry of originalPostIndex.posts) {
        const originalContent = fs.readFileSync(
          path.join(syncOutputDir, 'sync', 'posts', `${entry.id}.json`), 'utf8'
        );
        const importedContent = fs.readFileSync(
          path.join(importedOutputDir, 'sync', 'posts', `${entry.id}.json`), 'utf8'
        );

        const originalHash = calculateHash(originalContent);
        const importedHash = calculateHash(importedContent);

        expect(importedHash).toBe(originalHash);
      }
    });
  });

  describe('Deterministic Site Generation', () => {
    it('should generate identical site hashes when called twice', async () => {
      // Generate site first time
      const result1 = await generateSite(storage, blogId);

      // Generate site second time
      const result2 = await generateSite(storage, blogId);

      // Compare all file hashes
      const files1 = Object.keys(result1.fileHashes).sort();
      const files2 = Object.keys(result2.fileHashes).sort();

      expect(files1).toEqual(files2);

      for (const file of files1) {
        expect(result2.fileHashes[file]).toBe(result1.fileHashes[file]);
      }
    });

    it('should generate identical HTML for imported blog as original', async () => {
      // First, import the blog data into a fresh blog
      const clonedBlog = storage.createBlog({
        name: canonicalBlog.blog.name,
        url: canonicalBlog.blog.url,
        tagline: canonicalBlog.blog.tagline,
        authorName: canonicalBlog.blog.authorName,
        authorUrl: canonicalBlog.blog.authorUrl,
        authorEmail: canonicalBlog.blog.authorEmail,
        accentColor: canonicalBlog.blog.colors.accent,
        backgroundColor: canonicalBlog.blog.colors.background,
        textColor: canonicalBlog.blog.colors.text,
        lightShade: canonicalBlog.blog.colors.lightShade,
        mediumShade: canonicalBlog.blog.colors.mediumShade,
        darkShade: canonicalBlog.blog.colors.darkShade,
        themeIdentifier: canonicalBlog.blog.themeIdentifier,
      });
      const clonedBlogId = clonedBlog.id;

      // Read sync data from original blog's output
      const originalSyncDir = path.join(testDir, 'output', 'sync');

      // Import categories with syncId preserved
      const catIndex = JSON.parse(
        fs.readFileSync(path.join(originalSyncDir, 'categories', 'index.json'), 'utf8')
      );
      const clonedCategoryMap = new Map();
      for (const entry of catIndex.categories) {
        const catData = JSON.parse(
          fs.readFileSync(path.join(originalSyncDir, 'categories', `${entry.id}.json`), 'utf8')
        );
        const created = storage.createCategory(clonedBlogId, {
          name: catData.name,
          description: catData.description,
          stub: catData.stub,
          syncId: catData.id,
          createdAt: catData.createdAt,
        });
        clonedCategoryMap.set(catData.id, created.id);
      }

      // Import tags with syncId preserved
      const tagIndex = JSON.parse(
        fs.readFileSync(path.join(originalSyncDir, 'tags', 'index.json'), 'utf8')
      );
      const clonedTagMap = new Map();
      for (const entry of tagIndex.tags) {
        const tagData = JSON.parse(
          fs.readFileSync(path.join(originalSyncDir, 'tags', `${entry.id}.json`), 'utf8')
        );
        const created = storage.createTag(clonedBlogId, {
          name: tagData.name,
          stub: tagData.stub,
          syncId: tagData.id,
          createdAt: tagData.createdAt,
        });
        clonedTagMap.set(tagData.id, created.id);
      }

      // Import sidebar with syncId preserved
      const sidebarIndex = JSON.parse(
        fs.readFileSync(path.join(originalSyncDir, 'sidebar', 'index.json'), 'utf8')
      );
      for (const entry of sidebarIndex.sidebar) {
        const sidebarData = JSON.parse(
          fs.readFileSync(path.join(originalSyncDir, 'sidebar', `${entry.id}.json`), 'utf8')
        );
        storage.createSidebarObject(clonedBlogId, {
          title: sidebarData.title,
          type: sidebarData.type,
          content: sidebarData.content,
          order: sidebarData.order,
          links: sidebarData.links || [],
          syncId: sidebarData.id,
          createdAt: sidebarData.createdAt,
        });
      }

      // Import posts with syncId preserved
      const postIndex = JSON.parse(
        fs.readFileSync(path.join(originalSyncDir, 'posts', 'index.json'), 'utf8')
      );
      for (const entry of postIndex.posts) {
        const postData = JSON.parse(
          fs.readFileSync(path.join(originalSyncDir, 'posts', `${entry.id}.json`), 'utf8')
        );

        const categoryId = postData.categoryId ? clonedCategoryMap.get(postData.categoryId) : null;
        const tagIds = (postData.tagIds || []).map(id => clonedTagMap.get(id)).filter(Boolean);

        let embed = null;
        if (postData.embed) {
          embed = {
            type: postData.embed.type.toLowerCase(),
            position: postData.embed.position.toLowerCase(),
            url: postData.embed.url,
            title: postData.embed.title,
            description: postData.embed.description,
            imageUrl: postData.embed.imageUrl,
            imageFilename: postData.embed.imageFilename,
            images: postData.embed.images,
          };
        }

        storage.createPost(clonedBlogId, {
          title: postData.title,
          content: postData.content,
          stub: postData.stub,
          isDraft: false,
          categoryId: categoryId,
          tagIds: tagIds,
          embed: embed,
          syncId: postData.id,
          createdAt: postData.createdAt,
          updatedAt: postData.updatedAt,
        });
      }

      // Generate site for original blog
      const originalResult = await generateSite(storage, blogId);

      // Generate site for cloned/imported blog
      const clonedResult = await generateSite(storage, clonedBlogId);

      // Compare HTML file hashes (excluding sync files which may have different IDs)
      const htmlFiles = Object.keys(originalResult.fileHashes)
        .filter(f => f.endsWith('.html'))
        .sort();

      const mismatches = [];
      for (const file of htmlFiles) {
        const originalHash = originalResult.fileHashes[file];
        const clonedHash = clonedResult.fileHashes[file];

        if (originalHash !== clonedHash) {
          mismatches.push(file);
        }
      }

      if (mismatches.length > 0) {
        // Read the actual content to see the difference
        const firstMismatch = mismatches[0];
        const originalContent = fs.readFileSync(path.join(originalResult.outputDir, firstMismatch), 'utf8');
        const clonedContent = fs.readFileSync(path.join(clonedResult.outputDir, firstMismatch), 'utf8');

        console.log(`Mismatched files: ${mismatches.join(', ')}`);
        console.log(`First mismatch: ${firstMismatch}`);

        // Find the first difference
        for (let i = 0; i < Math.min(originalContent.length, clonedContent.length); i++) {
          if (originalContent[i] !== clonedContent[i]) {
            console.log(`First difference at position ${i}:`);
            console.log(`Original: ...${originalContent.substring(Math.max(0, i - 50), i + 100)}...`);
            console.log(`Cloned:   ...${clonedContent.substring(Math.max(0, i - 50), i + 100)}...`);
            break;
          }
        }
      }

      expect(mismatches).toHaveLength(0);
    });

    it('should generate identical non-HTML files for imported blog (RSS, sitemap, CSS, robots.txt)', async () => {
      // Use the cloned blog created in the previous test - create a fresh one here
      const clonedBlog2 = storage.createBlog({
        name: canonicalBlog.blog.name,
        url: canonicalBlog.blog.url,
        tagline: canonicalBlog.blog.tagline,
        authorName: canonicalBlog.blog.authorName,
        authorUrl: canonicalBlog.blog.authorUrl,
        authorEmail: canonicalBlog.blog.authorEmail,
        accentColor: canonicalBlog.blog.colors.accent,
        backgroundColor: canonicalBlog.blog.colors.background,
        textColor: canonicalBlog.blog.colors.text,
        lightShade: canonicalBlog.blog.colors.lightShade,
        mediumShade: canonicalBlog.blog.colors.mediumShade,
        darkShade: canonicalBlog.blog.colors.darkShade,
        themeIdentifier: canonicalBlog.blog.themeIdentifier,
      });
      const clonedBlogId2 = clonedBlog2.id;

      // Read sync data from original blog's output
      const originalSyncDir = path.join(testDir, 'output', 'sync');

      // Import all entities with syncId preserved (same as previous test)
      const catIndex = JSON.parse(
        fs.readFileSync(path.join(originalSyncDir, 'categories', 'index.json'), 'utf8')
      );
      const categoryMap = new Map();
      for (const entry of catIndex.categories) {
        const catData = JSON.parse(
          fs.readFileSync(path.join(originalSyncDir, 'categories', `${entry.id}.json`), 'utf8')
        );
        const created = storage.createCategory(clonedBlogId2, {
          name: catData.name,
          description: catData.description,
          stub: catData.stub,
          syncId: catData.id,
          createdAt: catData.createdAt,
        });
        categoryMap.set(catData.id, created.id);
      }

      const tagIndex = JSON.parse(
        fs.readFileSync(path.join(originalSyncDir, 'tags', 'index.json'), 'utf8')
      );
      const tagMap = new Map();
      for (const entry of tagIndex.tags) {
        const tagData = JSON.parse(
          fs.readFileSync(path.join(originalSyncDir, 'tags', `${entry.id}.json`), 'utf8')
        );
        const created = storage.createTag(clonedBlogId2, {
          name: tagData.name,
          stub: tagData.stub,
          syncId: tagData.id,
          createdAt: tagData.createdAt,
        });
        tagMap.set(tagData.id, created.id);
      }

      const sidebarIndex = JSON.parse(
        fs.readFileSync(path.join(originalSyncDir, 'sidebar', 'index.json'), 'utf8')
      );
      for (const entry of sidebarIndex.sidebar) {
        const sidebarData = JSON.parse(
          fs.readFileSync(path.join(originalSyncDir, 'sidebar', `${entry.id}.json`), 'utf8')
        );
        storage.createSidebarObject(clonedBlogId2, {
          title: sidebarData.title,
          type: sidebarData.type,
          content: sidebarData.content,
          order: sidebarData.order,
          links: sidebarData.links || [],
          syncId: sidebarData.id,
          createdAt: sidebarData.createdAt,
        });
      }

      const postIndex = JSON.parse(
        fs.readFileSync(path.join(originalSyncDir, 'posts', 'index.json'), 'utf8')
      );
      for (const entry of postIndex.posts) {
        const postData = JSON.parse(
          fs.readFileSync(path.join(originalSyncDir, 'posts', `${entry.id}.json`), 'utf8')
        );

        const categoryId = postData.categoryId ? categoryMap.get(postData.categoryId) : null;
        const tagIds = (postData.tagIds || []).map(id => tagMap.get(id)).filter(Boolean);

        let embed = null;
        if (postData.embed) {
          embed = {
            type: postData.embed.type.toLowerCase(),
            position: postData.embed.position.toLowerCase(),
            url: postData.embed.url,
            title: postData.embed.title,
            description: postData.embed.description,
            imageUrl: postData.embed.imageUrl,
            imageFilename: postData.embed.imageFilename,
            images: postData.embed.images,
          };
        }

        storage.createPost(clonedBlogId2, {
          title: postData.title,
          content: postData.content,
          stub: postData.stub,
          isDraft: false,
          categoryId: categoryId,
          tagIds: tagIds,
          embed: embed,
          syncId: postData.id,
          createdAt: postData.createdAt,
          updatedAt: postData.updatedAt,
        });
      }

      // Generate sites
      const originalResult = await generateSite(storage, blogId);
      const clonedResult = await generateSite(storage, clonedBlogId2);

      // Check non-HTML files
      const nonHtmlFiles = ['rss.xml', 'sitemap.xml', 'css/style.css', 'robots.txt'];

      for (const file of nonHtmlFiles) {
        const originalHash = originalResult.fileHashes[file];
        const clonedHash = clonedResult.fileHashes[file];

        expect(clonedHash).toBe(originalHash);
      }
    });

    it('should generate identical sync manifest file hashes for imported blog', async () => {
      // Generate sync data for both blogs
      const originalSyncOutputDir = path.join(testDir, 'original-sync-output');
      const importedSyncOutputDir = path.join(testDir, 'imported-sync-output');
      fs.mkdirSync(originalSyncOutputDir, { recursive: true });
      fs.mkdirSync(importedSyncOutputDir, { recursive: true });

      // Create a properly imported blog with all settings
      const originalSyncDir = path.join(testDir, 'output', 'sync');
      const blogData = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'blog.json'), 'utf8'));

      const syncTestBlog = storage.createBlog({
        name: blogData.name,
        url: blogData.url,
        tagline: blogData.tagline,
        authorName: blogData.authorName,
        authorUrl: blogData.authorUrl,
        authorEmail: blogData.authorEmail,
        accentColor: blogData.colors?.accent,
        backgroundColor: blogData.colors?.background,
        textColor: blogData.colors?.text,
        lightShade: blogData.colors?.lightShade,
        mediumShade: blogData.colors?.mediumShade,
        darkShade: blogData.colors?.darkShade,
        themeIdentifier: blogData.themeIdentifier,
      });
      const syncTestBlogId = syncTestBlog.id;

      // Import entities
      const catIndex = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'categories', 'index.json'), 'utf8'));
      const catMap = new Map();
      for (const entry of catIndex.categories) {
        const catData = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'categories', `${entry.id}.json`), 'utf8'));
        const created = storage.createCategory(syncTestBlogId, { name: catData.name, description: catData.description, stub: catData.stub, syncId: catData.id, createdAt: catData.createdAt });
        catMap.set(catData.id, created.id);
      }

      const tagIndex = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'tags', 'index.json'), 'utf8'));
      const tagMap = new Map();
      for (const entry of tagIndex.tags) {
        const tagData = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'tags', `${entry.id}.json`), 'utf8'));
        const created = storage.createTag(syncTestBlogId, { name: tagData.name, stub: tagData.stub, syncId: tagData.id, createdAt: tagData.createdAt });
        tagMap.set(tagData.id, created.id);
      }

      const sidebarIndex = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'sidebar', 'index.json'), 'utf8'));
      for (const entry of sidebarIndex.sidebar) {
        const sidebarData = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'sidebar', `${entry.id}.json`), 'utf8'));
        storage.createSidebarObject(syncTestBlogId, { title: sidebarData.title, type: sidebarData.type, content: sidebarData.content, order: sidebarData.order, links: sidebarData.links || [], syncId: sidebarData.id, createdAt: sidebarData.createdAt });
      }

      const postIndex = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'posts', 'index.json'), 'utf8'));
      for (const entry of postIndex.posts) {
        const postData = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'posts', `${entry.id}.json`), 'utf8'));
        const categoryId = postData.categoryId ? catMap.get(postData.categoryId) : null;
        const tagIds = (postData.tagIds || []).map(id => tagMap.get(id)).filter(Boolean);
        let embed = null;
        if (postData.embed) {
          embed = { type: postData.embed.type.toLowerCase(), position: postData.embed.position.toLowerCase(), url: postData.embed.url, title: postData.embed.title, description: postData.embed.description, imageUrl: postData.embed.imageUrl, imageFilename: postData.embed.imageFilename, images: postData.embed.images };
        }
        storage.createPost(syncTestBlogId, { title: postData.title, content: postData.content, stub: postData.stub, isDraft: false, categoryId: categoryId, tagIds: tagIds, embed: embed, syncId: postData.id, createdAt: postData.createdAt, updatedAt: postData.updatedAt });
      }

      const originalResult = await generateSyncDirectory(storage, blogId, originalSyncOutputDir);
      const importedResult = await generateSyncDirectory(storage, syncTestBlogId, importedSyncOutputDir);

      // Compare manifest file hashes (excluding manifest.json itself which has different timestamps)
      const originalManifest = JSON.parse(
        fs.readFileSync(path.join(originalSyncOutputDir, 'sync', 'manifest.json'), 'utf8')
      );
      const importedManifest = JSON.parse(
        fs.readFileSync(path.join(importedSyncOutputDir, 'sync', 'manifest.json'), 'utf8')
      );

      // Same files should exist
      const originalFiles = Object.keys(originalManifest.files).sort();
      const importedFiles = Object.keys(importedManifest.files).sort();
      expect(importedFiles).toEqual(originalFiles);

      // Same hashes for each file
      const hashMismatches = [];
      for (const file of originalFiles) {
        if (importedManifest.files[file].hash !== originalManifest.files[file].hash) {
          hashMismatches.push(file);
        }
      }

      if (hashMismatches.length > 0) {
        console.log('Hash mismatches in sync manifest:', hashMismatches);
        // Read first mismatched file to compare
        const firstMismatch = hashMismatches[0];
        const originalContent = fs.readFileSync(path.join(originalSyncOutputDir, 'sync', firstMismatch), 'utf8');
        const importedContent = fs.readFileSync(path.join(importedSyncOutputDir, 'sync', firstMismatch), 'utf8');
        console.log(`\nOriginal ${firstMismatch}:\n`, originalContent);
        console.log(`\nImported ${firstMismatch}:\n`, importedContent);
      }

      expect(hashMismatches).toHaveLength(0);

      // Content versions should match
      expect(importedResult.syncVersion).toBe(originalResult.syncVersion);
    });

    it('should generate the same file list for original and imported blogs', async () => {
      // Create another imported blog for this test
      const testBlog = storage.createBlog({
        name: canonicalBlog.blog.name,
        url: canonicalBlog.blog.url,
        tagline: canonicalBlog.blog.tagline,
        authorName: canonicalBlog.blog.authorName,
        authorUrl: canonicalBlog.blog.authorUrl,
        authorEmail: canonicalBlog.blog.authorEmail,
        accentColor: canonicalBlog.blog.colors.accent,
        backgroundColor: canonicalBlog.blog.colors.background,
        textColor: canonicalBlog.blog.colors.text,
        lightShade: canonicalBlog.blog.colors.lightShade,
        mediumShade: canonicalBlog.blog.colors.mediumShade,
        darkShade: canonicalBlog.blog.colors.darkShade,
        themeIdentifier: canonicalBlog.blog.themeIdentifier,
      });
      const testBlogId = testBlog.id;

      // Import from sync data
      const originalSyncDir = path.join(testDir, 'output', 'sync');

      const catIndex = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'categories', 'index.json'), 'utf8'));
      const categoryMap = new Map();
      for (const entry of catIndex.categories) {
        const catData = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'categories', `${entry.id}.json`), 'utf8'));
        const created = storage.createCategory(testBlogId, { name: catData.name, description: catData.description, stub: catData.stub, syncId: catData.id, createdAt: catData.createdAt });
        categoryMap.set(catData.id, created.id);
      }

      const tagIndex = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'tags', 'index.json'), 'utf8'));
      const tagMap = new Map();
      for (const entry of tagIndex.tags) {
        const tagData = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'tags', `${entry.id}.json`), 'utf8'));
        const created = storage.createTag(testBlogId, { name: tagData.name, stub: tagData.stub, syncId: tagData.id, createdAt: tagData.createdAt });
        tagMap.set(tagData.id, created.id);
      }

      const sidebarIndex = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'sidebar', 'index.json'), 'utf8'));
      for (const entry of sidebarIndex.sidebar) {
        const sidebarData = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'sidebar', `${entry.id}.json`), 'utf8'));
        storage.createSidebarObject(testBlogId, { title: sidebarData.title, type: sidebarData.type, content: sidebarData.content, order: sidebarData.order, links: sidebarData.links || [], syncId: sidebarData.id, createdAt: sidebarData.createdAt });
      }

      const postIndex = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'posts', 'index.json'), 'utf8'));
      for (const entry of postIndex.posts) {
        const postData = JSON.parse(fs.readFileSync(path.join(originalSyncDir, 'posts', `${entry.id}.json`), 'utf8'));
        const categoryId = postData.categoryId ? categoryMap.get(postData.categoryId) : null;
        const tagIds = (postData.tagIds || []).map(id => tagMap.get(id)).filter(Boolean);
        let embed = null;
        if (postData.embed) {
          embed = { type: postData.embed.type.toLowerCase(), position: postData.embed.position.toLowerCase(), url: postData.embed.url, title: postData.embed.title, description: postData.embed.description, imageUrl: postData.embed.imageUrl, imageFilename: postData.embed.imageFilename, images: postData.embed.images };
        }
        storage.createPost(testBlogId, { title: postData.title, content: postData.content, stub: postData.stub, isDraft: false, categoryId: categoryId, tagIds: tagIds, embed: embed, syncId: postData.id, createdAt: postData.createdAt, updatedAt: postData.updatedAt });
      }

      // Generate sites
      const originalResult = await generateSite(storage, blogId);
      const testResult = await generateSite(storage, testBlogId);

      // Compare file lists (excluding sync/ files which use local IDs in paths)
      const originalFiles = Object.keys(originalResult.fileHashes)
        .filter(f => !f.startsWith('sync/'))
        .sort();
      const testFiles = Object.keys(testResult.fileHashes)
        .filter(f => !f.startsWith('sync/'))
        .sort();

      expect(testFiles).toEqual(originalFiles);
    });

    it('should maintain consistent ordering of posts in archives', async () => {
      // Generate site twice and compare archive pages
      const result1 = await generateSite(storage, blogId);
      const result2 = await generateSite(storage, blogId);

      // Check archives index
      expect(result2.fileHashes['archives/index.html']).toBe(result1.fileHashes['archives/index.html']);

      // Check monthly archives
      const monthlyArchives = Object.keys(result1.fileHashes)
        .filter(f => f.match(/^\d{4}\/\d{2}\/index\.html$/));

      for (const archive of monthlyArchives) {
        expect(result2.fileHashes[archive]).toBe(result1.fileHashes[archive]);
      }
    });

    it('should maintain consistent ordering of tags and categories in index pages', async () => {
      const result1 = await generateSite(storage, blogId);
      const result2 = await generateSite(storage, blogId);

      expect(result2.fileHashes['tags/index.html']).toBe(result1.fileHashes['tags/index.html']);
      expect(result2.fileHashes['categories/index.html']).toBe(result1.fileHashes['categories/index.html']);
    });
  });
});
