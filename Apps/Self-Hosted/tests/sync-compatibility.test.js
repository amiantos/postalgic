/**
 * Sync Compatibility Tests
 *
 * These tests verify that the sync data generated by the Self-Hosted app
 * matches the expected structure and is compatible with the iOS app.
 */

import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import os from 'os';
import { v4 as uuidv4 } from 'uuid';

// Import the modules we're testing
import { generateSyncDirectory } from '../server/services/syncGenerator.js';
import Storage from '../server/utils/storage.js';
import { initDatabase, closeDatabase } from '../server/utils/database.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Load test fixtures
const fixturesDir = path.join(__dirname, '../../..', 'test-fixtures/sync-compatibility');
const canonicalBlog = JSON.parse(fs.readFileSync(path.join(fixturesDir, 'canonical-blog.json'), 'utf8'));
const expectedStructure = JSON.parse(fs.readFileSync(path.join(fixturesDir, 'expected-sync-structure.json'), 'utf8'));

describe('Sync Data Compatibility', () => {
  let storage;
  let testDir;
  let blogId;
  let testIdToRealId = {};

  beforeAll(() => {
    // Create a temporary directory for test data
    testDir = path.join(os.tmpdir(), `postalgic-test-${uuidv4()}`);
    fs.mkdirSync(testDir, { recursive: true });

    // Initialize database first
    initDatabase(testDir);

    // Initialize storage with test directory
    storage = new Storage(testDir);

    // Create blog from fixture
    const blog = storage.createBlog({
      name: canonicalBlog.blog.name,
      url: canonicalBlog.blog.url,
      tagline: canonicalBlog.blog.tagline,
      authorName: canonicalBlog.blog.authorName,
      authorUrl: canonicalBlog.blog.authorUrl,
      authorEmail: canonicalBlog.blog.authorEmail,
      accentColor: canonicalBlog.blog.colors.accent,
      backgroundColor: canonicalBlog.blog.colors.background,
      textColor: canonicalBlog.blog.colors.text,
      lightShade: canonicalBlog.blog.colors.lightShade,
      mediumShade: canonicalBlog.blog.colors.mediumShade,
      darkShade: canonicalBlog.blog.colors.darkShade,
      themeIdentifier: canonicalBlog.blog.themeIdentifier,
    });
    blogId = blog.id;

    // Enable sync for the blog
    storage.saveSyncConfig(blogId, {
      syncEnabled: true,
      syncPassword: canonicalBlog.encryption.testPassword,
      lastSyncedAt: null,
      lastSyncedVersion: 0,
    });

    // Create categories
    for (const cat of canonicalBlog.categories) {
      const created = storage.createCategory(blogId, {
        name: cat.name,
        description: cat.description,
        stub: cat.stub,
      });
      testIdToRealId[cat.testId] = created.id;
    }

    // Create tags
    for (const tag of canonicalBlog.tags) {
      const created = storage.createTag(blogId, {
        name: tag.name,
        stub: tag.stub,
      });
      testIdToRealId[tag.testId] = created.id;
    }

    // Create posts (published)
    for (const post of canonicalBlog.posts) {
      const categoryId = post.categoryTestId ? testIdToRealId[post.categoryTestId] : null;
      const tagIds = post.tagTestIds.map(tid => testIdToRealId[tid]);

      let embed = null;
      if (post.embed) {
        embed = {
          type: post.embed.type.toLowerCase(),
          position: post.embed.position.toLowerCase(),
          url: post.embed.url,
          title: post.embed.title,
          description: post.embed.description,
          imageUrl: post.embed.imageUrl,
          imageFilename: post.embed.imageFilename,
          images: post.embed.images,
        };
      }

      const created = storage.createPost(blogId, {
        title: post.title,
        content: post.content,
        stub: post.stub,
        isDraft: post.isDraft,
        categoryId: categoryId,
        tagIds: tagIds,
        embed: embed,
        createdAt: post.createdAt,
      });
      testIdToRealId[post.testId] = created.id;
    }

    // Create drafts
    for (const draft of canonicalBlog.drafts) {
      const categoryId = draft.categoryTestId ? testIdToRealId[draft.categoryTestId] : null;
      const tagIds = draft.tagTestIds.map(tid => testIdToRealId[tid]);

      const created = storage.createPost(blogId, {
        title: draft.title,
        content: draft.content,
        stub: draft.stub,
        isDraft: true,
        categoryId: categoryId,
        tagIds: tagIds,
        embed: null,
        createdAt: draft.createdAt,
      });
      testIdToRealId[draft.testId] = created.id;
    }

    // Create sidebar objects
    for (const sidebar of canonicalBlog.sidebar) {
      const created = storage.createSidebarObject(blogId, {
        type: sidebar.type,
        title: sidebar.title,
        content: sidebar.content,
        order: sidebar.order,
        links: sidebar.links,
      });
      testIdToRealId[sidebar.testId] = created.id;
    }
  });

  afterAll(() => {
    // Close database first
    closeDatabase();

    // Clean up test directory
    if (testDir && fs.existsSync(testDir)) {
      fs.rmSync(testDir, { recursive: true, force: true });
    }
  });

  describe('Sync Directory Generation', () => {
    let syncOutputDir;
    let syncResult;

    beforeAll(async () => {
      // Generate sync directory
      syncOutputDir = path.join(testDir, 'output');
      fs.mkdirSync(syncOutputDir, { recursive: true });

      syncResult = await generateSyncDirectory(
        storage,
        blogId,
        syncOutputDir,
        canonicalBlog.encryption.testPassword
      );
    });

    it('should create manifest.json', () => {
      const manifestPath = path.join(syncOutputDir, 'sync', 'manifest.json');
      expect(fs.existsSync(manifestPath)).toBe(true);
    });

    it('should have all required manifest fields', () => {
      const manifest = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'manifest.json'), 'utf8')
      );

      for (const field of expectedStructure.manifest.requiredFields) {
        expect(manifest).toHaveProperty(field);
      }
    });

    it('should have correct manifest field types', () => {
      const manifest = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'manifest.json'), 'utf8')
      );

      expect(typeof manifest.version).toBe('string');
      expect(typeof manifest.syncVersion).toBe('number');
      expect(typeof manifest.lastModified).toBe('string');
      expect(typeof manifest.appSource).toBe('string');
      expect(typeof manifest.blogName).toBe('string');
      expect(typeof manifest.hasDrafts).toBe('boolean');
      expect(typeof manifest.files).toBe('object');
    });

    it('should create blog.json with correct structure', () => {
      const blogPath = path.join(syncOutputDir, 'sync', 'blog.json');
      expect(fs.existsSync(blogPath)).toBe(true);

      const blogData = JSON.parse(fs.readFileSync(blogPath, 'utf8'));

      for (const field of expectedStructure.blog.requiredFields) {
        expect(blogData).toHaveProperty(field);
      }

      expect(blogData.name).toBe(canonicalBlog.blog.name);
      expect(blogData.url).toBe(canonicalBlog.blog.url);
    });

    it('should create categories index and individual files', () => {
      const indexPath = path.join(syncOutputDir, 'sync', 'categories', 'index.json');
      expect(fs.existsSync(indexPath)).toBe(true);

      const index = JSON.parse(fs.readFileSync(indexPath, 'utf8'));
      expect(index.categories).toHaveLength(canonicalBlog.categories.length);

      // Check each category file exists
      for (const entry of index.categories) {
        const catPath = path.join(syncOutputDir, 'sync', 'categories', `${entry.id}.json`);
        expect(fs.existsSync(catPath)).toBe(true);
      }
    });

    it('should create tags index and individual files', () => {
      const indexPath = path.join(syncOutputDir, 'sync', 'tags', 'index.json');
      expect(fs.existsSync(indexPath)).toBe(true);

      const index = JSON.parse(fs.readFileSync(indexPath, 'utf8'));
      expect(index.tags).toHaveLength(canonicalBlog.tags.length);

      // Check each tag file exists
      for (const entry of index.tags) {
        const tagPath = path.join(syncOutputDir, 'sync', 'tags', `${entry.id}.json`);
        expect(fs.existsSync(tagPath)).toBe(true);
      }
    });

    it('should create posts index and individual files', () => {
      const indexPath = path.join(syncOutputDir, 'sync', 'posts', 'index.json');
      expect(fs.existsSync(indexPath)).toBe(true);

      const index = JSON.parse(fs.readFileSync(indexPath, 'utf8'));
      expect(index.posts).toHaveLength(canonicalBlog.posts.length);

      // Check each post file exists
      for (const entry of index.posts) {
        const postPath = path.join(syncOutputDir, 'sync', 'posts', `${entry.id}.json`);
        expect(fs.existsSync(postPath)).toBe(true);
      }
    });

    it('should create sidebar index and individual files', () => {
      const indexPath = path.join(syncOutputDir, 'sync', 'sidebar', 'index.json');
      expect(fs.existsSync(indexPath)).toBe(true);

      const index = JSON.parse(fs.readFileSync(indexPath, 'utf8'));
      expect(index.sidebar).toHaveLength(canonicalBlog.sidebar.length);

      // Check each sidebar file exists
      for (const entry of index.sidebar) {
        const sidebarPath = path.join(syncOutputDir, 'sync', 'sidebar', `${entry.id}.json`);
        expect(fs.existsSync(sidebarPath)).toBe(true);
      }
    });

    it('should create encrypted drafts when drafts exist', () => {
      const indexPath = path.join(syncOutputDir, 'sync', 'drafts', 'index.json.enc');
      expect(fs.existsSync(indexPath)).toBe(true);

      // Check manifest indicates drafts are encrypted
      const manifest = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'manifest.json'), 'utf8')
      );
      expect(manifest.hasDrafts).toBe(true);
      expect(manifest.encryption).toBeDefined();
      expect(manifest.encryption.method).toBe('aes-256-gcm');
      expect(manifest.encryption.iterations).toBe(100000);
    });

    it('should have valid SHA-256 hashes in manifest', () => {
      const manifest = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'manifest.json'), 'utf8')
      );

      const sha256Regex = /^[a-f0-9]{64}$/;

      for (const [filePath, fileInfo] of Object.entries(manifest.files)) {
        expect(fileInfo.hash).toMatch(sha256Regex);
      }
    });

    it('should have IVs for encrypted files', () => {
      const manifest = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'manifest.json'), 'utf8')
      );

      for (const [filePath, fileInfo] of Object.entries(manifest.files)) {
        if (filePath.endsWith('.enc')) {
          expect(fileInfo.encrypted).toBe(true);
          expect(fileInfo.iv).toBeDefined();
          expect(typeof fileInfo.iv).toBe('string');
        }
      }
    });

    it('should have contentHash for encrypted files', () => {
      const manifest = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'manifest.json'), 'utf8')
      );

      const sha256Regex = /^[a-f0-9]{64}$/;
      let encryptedFilesCount = 0;

      for (const [filePath, fileInfo] of Object.entries(manifest.files)) {
        if (fileInfo.encrypted) {
          encryptedFilesCount++;
          // Each encrypted file should have a contentHash
          expect(fileInfo.contentHash).toBeDefined();
          expect(fileInfo.contentHash).toMatch(sha256Regex);
          // contentHash should be different from hash (since hash is of ciphertext)
          expect(fileInfo.contentHash).not.toBe(fileInfo.hash);
        }
      }

      // We should have at least some encrypted files
      expect(encryptedFilesCount).toBeGreaterThan(0);
    });

    it('should have stable contentHash across multiple generations', async () => {
      // Generate sync data a second time
      const syncOutputDir2 = path.join(testDir, 'output2');
      fs.mkdirSync(syncOutputDir2, { recursive: true });

      await generateSyncDirectory(
        storage,
        blogId,
        syncOutputDir2,
        canonicalBlog.encryption.testPassword
      );

      // Load both manifests
      const manifest1 = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'manifest.json'), 'utf8')
      );
      const manifest2 = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir2, 'sync', 'manifest.json'), 'utf8')
      );

      // For encrypted files, contentHash should be the same even though hash differs
      for (const [filePath, fileInfo1] of Object.entries(manifest1.files)) {
        if (fileInfo1.encrypted) {
          const fileInfo2 = manifest2.files[filePath];
          expect(fileInfo2).toBeDefined();

          // contentHash should be stable
          expect(fileInfo1.contentHash).toBe(fileInfo2.contentHash);

          // Regular hash (of ciphertext) should differ due to random IV
          expect(fileInfo1.hash).not.toBe(fileInfo2.hash);
        }
      }
    });
  });

  describe('Post Structure', () => {
    let syncOutputDir;

    beforeAll(async () => {
      syncOutputDir = path.join(testDir, 'output');
    });

    it('should have correct post structure with embed', () => {
      const indexPath = path.join(syncOutputDir, 'sync', 'posts', 'index.json');
      const index = JSON.parse(fs.readFileSync(indexPath, 'utf8'));

      // Find a post with embed
      for (const entry of index.posts) {
        const postPath = path.join(syncOutputDir, 'sync', 'posts', `${entry.id}.json`);
        const post = JSON.parse(fs.readFileSync(postPath, 'utf8'));

        // Check required fields
        expect(post).toHaveProperty('id');
        expect(post).toHaveProperty('content');
        expect(post).toHaveProperty('stub');
        expect(post).toHaveProperty('createdAt');
        expect(post).toHaveProperty('updatedAt');

        // If has embed, check embed structure
        if (post.embed) {
          expect(post.embed).toHaveProperty('type');
          expect(post.embed).toHaveProperty('position');
          expect(['YouTube', 'Link', 'Image']).toContain(post.embed.type);
          expect(['above', 'below']).toContain(post.embed.position);
        }
      }
    });

    it('should have valid category references', () => {
      const postIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'posts', 'index.json'), 'utf8')
      );
      const catIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'categories', 'index.json'), 'utf8')
      );

      const validCategoryIds = new Set(catIndex.categories.map(c => c.id));

      for (const entry of postIndex.posts) {
        const postPath = path.join(syncOutputDir, 'sync', 'posts', `${entry.id}.json`);
        const post = JSON.parse(fs.readFileSync(postPath, 'utf8'));

        if (post.categoryId) {
          expect(validCategoryIds.has(post.categoryId)).toBe(true);
        }
      }
    });

    it('should have valid tag references', () => {
      const postIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'posts', 'index.json'), 'utf8')
      );
      const tagIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'tags', 'index.json'), 'utf8')
      );

      const validTagIds = new Set(tagIndex.tags.map(t => t.id));

      for (const entry of postIndex.posts) {
        const postPath = path.join(syncOutputDir, 'sync', 'posts', `${entry.id}.json`);
        const post = JSON.parse(fs.readFileSync(postPath, 'utf8'));

        if (post.tagIds && post.tagIds.length > 0) {
          for (const tagId of post.tagIds) {
            expect(validTagIds.has(tagId)).toBe(true);
          }
        }
      }
    });
  });

  describe('Date Format', () => {
    let syncOutputDir;

    beforeAll(async () => {
      syncOutputDir = path.join(testDir, 'output');
    });

    it('should use ISO 8601 date format', () => {
      const iso8601Regex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/;

      // Check manifest
      const manifest = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'manifest.json'), 'utf8')
      );
      expect(manifest.lastModified).toMatch(iso8601Regex);

      // Check posts
      const postIndex = JSON.parse(
        fs.readFileSync(path.join(syncOutputDir, 'sync', 'posts', 'index.json'), 'utf8')
      );

      for (const entry of postIndex.posts) {
        const postPath = path.join(syncOutputDir, 'sync', 'posts', `${entry.id}.json`);
        const post = JSON.parse(fs.readFileSync(postPath, 'utf8'));
        expect(post.createdAt).toMatch(iso8601Regex);
        expect(post.updatedAt).toMatch(iso8601Regex);
      }
    });
  });
});
